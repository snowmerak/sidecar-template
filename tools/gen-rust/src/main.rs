use std::fs;
use std::path::Path;
use walkdir::WalkDir;

fn main() -> anyhow::Result<()> {
    let proto_root = Path::new("../../proto");
    let out_dir = Path::new("../../gen/rust/src");

    // 1. Clean output directory (optional, but good for safety)
    if out_dir.exists() {
        fs::remove_dir_all(out_dir)?;
    }
    fs::create_dir_all(out_dir)?;

    // 2. Find all .proto files
    let mut protos = Vec::new();
    for entry in WalkDir::new(proto_root) {
        let entry = entry?;
        if entry.path().extension().map_or(false, |ext| ext == "proto") {
            protos.push(entry.path().to_owned());
        }
    }

    if protos.is_empty() {
        println!("No proto files found.");
        return Ok(());
    }

    // 3. Run tonic-build
    tonic_build::configure()
        .out_dir(out_dir)
        // Add Serde traits to all generated structs
        .type_attribute(".", "#[derive(serde::Serialize, serde::Deserialize)]")
        // Optional: Use camelCase for JSON fields to match standard JSON conventions
        .type_attribute(".", "#[serde(rename_all = \"camelCase\")]")
        .compile(&protos, &[proto_root])?;

    // 4. Generate lib.rs automatically
    let mut lib_rs_content = String::new();
    lib_rs_content.push_str("// @generated\n// Auto-generated by tools/gen-rust. Do not edit.\n\n");

    // Read generated files to find modules
    let mut modules = Vec::new();
    for entry in fs::read_dir(out_dir)? {
        let entry = entry?;
        let path = entry.path();
        if path.extension().map_or(false, |ext| ext == "rs") {
            let file_name = path.file_stem().unwrap().to_string_lossy().to_string();
            if file_name == "lib" { continue; } // Skip lib.rs itself
            modules.push(file_name);
        }
    }
    modules.sort();

    for mod_name in modules {
        // tonic generates "package.name.rs"
        // We want to expose them as modules.
        // Since filenames have dots, we can't just use `mod package.name;`
        // We use `#[path = "..."] mod package_name;` strategy or just flat re-exports.
        
        // Strategy: Use the filename as the module name (with underscores replacing dots if needed, 
        // but tonic files are usually like `company.auth.v1.rs`)
        // Rust identifiers can't have dots.
        
        let safe_mod_name = mod_name.replace('.', "_");
        lib_rs_content.push_str(&format!("#[path = \"{}.rs\"]\n", mod_name));
        lib_rs_content.push_str(&format!("pub mod {};\n\n", safe_mod_name));
    }

    fs::write(out_dir.join("lib.rs"), lib_rs_content)?;

    println!("Rust code generated successfully in {:?}", out_dir);
    Ok(())
}
